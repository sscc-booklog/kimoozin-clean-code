이번 주에 읽은 내용은 객체지향 설계의 본질, 오류 처리의 원칙, 그리고 클래스 설계 원칙에 관한 것이다.

1. 다음은 객체와 자료구조에 관한 내용이다.
먼저, 객체와 자료구조의 차이에 대해 다루었다. 단순히 변수 사이에 함수를 끼워 넣는다고 해서 구현이 감춰지는 것은 아니다. 진정한 의미의 정보 은닉은 추상화를 통해 이루어진다. 즉, 조회 함수나 설정 함수를 제공한다고 해서 그 자체로 클래스가 되는 것은 아니다. 사용자가 내부 구현을 전혀 알지 못한 채 핵심적인 동작만을 조작할 수 있도록 추상 인터페이스를 제공해야만 클래스라 할 수 있다.
  
객체는 추상화 뒤에서 데이터를 숨기고, 데이터를 다루는 함수만 공개한다. 반면 자료구조는 데이터를 그대로 공개하며, 별다른 동작(함수)을 제공하지 않는다. 이 둘은 본질적으로 상반된 개념이다. 자료구조를 사용하는 절차적인 코드는 기존 자료구조를 변경하지 않고 새로운 함수를 추가하기 쉽지만, 새로운 자료구조를 추가하려면 모든 함수를 수정해야 한다. 반대로 객체지향 코드는 기존 함수를 수정하지 않고 새로운 객체 타입(클래스) 을 추가하기는 쉽지만, 새로운 함수를 추가하려면 모든 클래스를 수정해야 한다.

이 두 접근법의 장단점을 혼합한 잡종 구조는 오히려 양쪽의 단점을 모두 가지게 된다. 잡종 구조에서는 새로운 함수도, 새로운 자료구조도 쉽게 추가할 수 없기 때문에 피해야 한다.
결국 객체는 “동작을 공개하고 자료를 숨기는” 것이 핵심이다. 따라서 시스템 구현 시 새로운 자료 타입을 자주 추가해야 하는 경우에는 객체지향 방식이 적합하고, 새로운 동작(함수)을 자주 추가해야 하는 경우에는 절차적 방식이 더 유리하다. 우수한 개발자는 이러한 차이를 이해하고, 상황에 따라 가장 적합한 방법을 선택할 수 있어야 한다.




2. 다음은 오류 처리에 관한 내용이다.
여러 곳에 흩어진 오류 처리 코드는 실제 로직의 의도를 흐리게 만든다. 따라서 오류 코드는 되도록 예외(Exception) 로 대체해야 한다. 예외를 사용하면 정상 로직과 오류 처리 로직이 분리되어 코드가 훨씬 깔끔해진다.
  예외가 발생할 가능성이 있는 코드를 작성할 때는 try-catch-finally 블록을 먼저 고려해야 한다. 이렇게 하면 예외가 발생하더라도 호출자가 기대하는 프로그램 상태를 유지하기 쉬워진다.

또한 checked 예외는 상위 계층이 하위 계층의 구체적인 구현(어떤 예외가 발생하는지)을 알아야 하므로 추상화가 새는 문제(leaky abstraction) 를 일으킨다. 이를 피하려면 외부 API를 감싸는(wrapper) 기법을 사용하여 외부 라이브러리에 대한 의존성을 줄이는 것이 좋다.

또 하나의 중요한 개념은 특수 사례 패턴(Special Case Pattern) 이다. 이는 예외적인 상황을 별도의 객체나 클래스 형태로 캡슐화하여, 클라이언트 코드가 직접 예외 처리를 하지 않아도 되도록 만드는 방식이다.
마지막으로, null을 반환하거나 전달하지 말아야 한다. 대신 예외를 던지거나, 특수 사례 객체를 반환하거나, assert 문을 통해 문제를 명확히 드러내야 한다.




3. 마지막으로 클래스 설계의 원칙을 살펴보았다.

자바의 표준적인 클래스 정의 순서는 다음과 같다:
1. 변수 선언 (정적 공개 → 정적 비공개 → 비공개 인스턴스 변수 순)
2. 공개 함수
3. 비공개 함수 (해당 함수를 호출하는 공개 함수 바로 아래 위치)

이 순서는 추상화 수준이 위에서 아래로 자연스럽게 내려가는 구조를 만든다.

클래스는 작아야 하며, 이름만 보아도 하나의 명확한 책임을 알 수 있어야 한다.
이와 관련된 원칙이 바로 단일 책임 원칙(SRP, Single Responsibility Principle) 으로, 클래스나 모듈은 오직 하나의 변경 이유만 가져야 한다.
큰 클래스를 여러 개 두는 것보다, 작고 응집도 높은 클래스들을 협력시키는 것이 훨씬 좋은 설계다.

응집도가 높은 클래스는 그 안의 메서드와 변수가 서로 긴밀히 관련되어 있으며, 논리적으로 하나의 단위를 이룬다. 만약 어떤 인스턴스 변수가 일부 메서드에서만 사용된다면, 이는 새로운 클래스로 분리해야 한다는 신호다.
변수와 메서드를 적절히 묶어 클래스를 나누면 응집도가 높아지고 유지보수가 쉬워진다.

또한 깨끗한 시스템은 클래스 간의 의존성을 최소화하여 변경 시 위험을 줄인다.
구체적인 구현에 의존하는 코드는 구현이 바뀔 때 쉽게 깨지므로, 이를 방지하기 위해 인터페이스나 추상 클래스를 통해 구현을 격리해야 한다.
클래스는 작고 응집도 높게 설계하며, 하나의 책임(SRP) 만 가진다.

구체적인 구현보다 추상 인터페이스에 의존해야 유지보수성이 높다.
